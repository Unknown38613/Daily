So good morning everyone, I am going to explain a technical topic that we were taught during our training that is Web Automation Testing using Selenium, 

So what exactly is selenium,
It is a web automation testing tool that simulates real user interaction with browser and verify whether the web application behaves as it is supposed to be.

This tool was created to overcome shortcomings of Manual Testing. Manual testing involved performing actions on browser physically, which was both time consuming and prone to error, also modern websites are far more complex that of early html templates, thus making it difficult to handle web interaction physically.

Selenium automates browser actions like filling input form, clicking button, navigation to sub pages etc which reduces time and effort, but you might be thinking why only selenium why not some other automation tool, 
So obviously selenium is open source, it supports multiple OS, it supports multiple browsers, multiple programming languages, also selenium is recognized as web automation standard due to their policies and compliances that they follow.
-------------------------------------------------------------------

Then we have selenium suite, it is important to remember that selenium is not just a single tool but rather a suite of tools, which make automation testing easy.
The suite mainly contains 4 components : 
First and main one is Selenium Web Driver - 
 It automates browser actions by directly communicating with browser, it works with multiple programming languages, multiple browsers, allow interaction with web elements like forms, buttons, links, etc
It can also simulate real user actions like typing, scrolling, drag and drop, etc. It is considered ideal for writing test scripts for complex web applications.

Then we have selenium IDE, which is a browser extension for quick test creation using record and playback. It usually records the user interaction with browser and store that actions as test steps in script and then user can play back the recorded steps to repeat the test.

Then we have Selenium Grid, which is entire system that consist of Hub or central server which receives test requests and then those test requests are distributed to Nodes or Browsers where test are actually executed. The main advantage of this is it allows parallel execution across different environments which allows more test coverage.

Then we have Selenium RC that is Remote Control, it is deprecated software, which is acted like middleman between script and browser, injecting JavaScript directly into the browser, but since modern browsers have rejected JavaScript injections due to vulnerability issues, it is not longer used.
-------------------------------------------------------------------

Now we have selenium web driver, WebDriver acts as a bridge between your test script and the browser. As we have learned selenium for Java, WebDriver is a interface in java provided by selenium library.
 Webdriver in java defines core methods like get(), findElement(), etc which are common to all different webdrivers.
Then in down hierarchy we have RemoteWebDriver Class which implements webdriver along with other interfaces and then browser-specific driver classes in which instantiate our browser.
The core concept of selenium lies in that every interactable element on a web page is treated as web element.
The setup for performing automation testing using requires just two dependencies in Java or Maven project i.e, either installing selenium web driver JAR files or adding selenium java maven dependency directly in pom.xml. And second is installing browser specific driver. 

-------------------------------------------------------------------
Then next foremost important thing selenium provides is element locators. They are strategies to find HTML elements in the DOM, so that selenium can perform actions on it.
using findElement() method of webdriver interface we can use various combinations of locators to accurately locate the HTML element. It involve findelement by Class Name which finds element by class, then we have ID selector, element name selector, tag name selector, then we have css selector, xpath selector, link text selector

-------------------------------------------------------------------
Then we have wait mechanisms in selenium as we know that modern websites use virtual DOM which takes time to render original DOM, so for such situations waits ensure that selenium driver wait for appropriate time duration before proceeding to find element. 
We have three types of wait associated with selenium : first one is Implicit wait, it is inbuilt selenium configuration built directly inside webdriver instance, that applies a global wait to entire session. It tells webdriver to wait for certain time when the element is not immediately found.
Then we have one interface that is Wait Interface that provides the until() method, which waits for a condition to become true.
Based on the wait interface, we have FluentWait class , which accepts three parameters that is maximum wait time, polling frequency, exceptions to ignore, which offers more control over wait behavior. This is usually used when we want to have more control over wait.
Then we also a simpler implementation of wait interface, which is done by WebDriverWait class extending fluent wait class, also known as Explicit wait. It is applied to specific element or condition unlike implicit wait. It is useful when some element might require more time than other elements.
-------------------------------------------------------------------

Then talking about types of exception occurred while
while running selenium script, 
first is nosuchelementexception it occurs when element we are trying to locate isn't present in DOM due to incorrect locater or element hasn't loaded yet.

second is elementnotinteractableexception, it occurs when element is present but not interactable maybe when the element's visibility type is hidden.

third is staleelementreferenceexception, it occurs when element was found earlier but no longer exist in DOM may due to virtual DOM or dynamic content rendering.

fourth is timeoutexcepiton which mostly occurs when wait finishes it's time limit and element never appears or condition isn't met.

fifth and sixth are nosuchframe and nosuchwindowexception usually occurs when we are trying to switch to a frame or window that doesn't exist or is closed.

seventh is noalertpresentexception,occurs when element locator for alert is present but the alert didn't appear or locator was unable to find the alert.

eighth is invalidselectorexception occurs when we mistyped locator name

ninth is javascriptexception which occurs when invalid JS code is present in website

tenth is webdriverexception which occurs when there is browser crash, webdriver api communication issue.
-------------------------------------------------------------------

Then we have some advance features that are provided by selenium for handling complex web elements and scenarios 
First one is JavaScriptExecutor Interface , it is mostly used when normal ElementLocators failed to interact with element, like some web application uses custom control over html code that don't behave like normal html code, hence javascript help us to interact with that code, some other example includes:
Clicking on hidden element when the element is not visible, like in this code .. js refers to JavascriptExecutor Reference variable, executeScript() is method that executes JS code in currently loaded page, arguments is built in JS object that hold all argument passed to function, hence argument[0] refers to first argument, .click() is JS method to simulate mouse click, so this code forces the button to be clicked even when it is hidden.

then, selenium can't directly scroll the website hence we take help of JS executor , then sometimes standard sendKeys() implementation may fail to fill input field, then JS executor will dynamically assign value to that input field bypassing text typing.

Then the second advance feature is handling alert, Alert Interface from Selenium handles all kinds of alert , as we all know that alerts are not part of normal HTML DOM tree, we can't handle them using ids and xpaths, Alerts are modal in nature i.e, they block interaction with rest of web elements until we accept or dismiss them, so Alert interface provides accept() method to accept the alert or dismiss() method to dismiss the alert, based on type of alert we can use it.
For simple alert as there is only okay button present we can use accept() method directly, to accept the alert, 
For confirmation alert we can either use accept() or we can use dismiss() method which will act on cancel button of that alert.
For alert that requires Prompt input, we can use sendKeys() with appropriate text then click on Ok using accept() method.
There is also a getText() method that will help in getting the message that was displayed in alert.



